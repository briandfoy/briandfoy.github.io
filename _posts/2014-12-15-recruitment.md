---
layout: post
title: My Perl recruitment thoughts
tags: opinion perl rescued-content
---

*I originally wrote this on blogs.perl.org [My Perl recruitment thoughts](http://blogs.perl.org/users/brian_d_foy/2014/12/my-perl-recruitment-thoughts.html)*

---

Dave Cross posted his [Perl
Recruitment Thoughts](http://perlhacks.com/2014/12/perl-recruitment-thoughts/), which led to the same tired responses we see
every time someone is frustrated enough to bring it up. Again. In the
past decade I've written this post about every six months, decided it
wasn't worth the shitstorm I'd get for posting it, then let it die.
This time, I'll write just the highlights, turn off comments, and let
people who care enough rant do it on their own blogs.

First, Dave does quite a bit of work to make new Perl programmers. He
teaches accessible and cheap classes in London (and anywhere that will
have him). I don't work in UK, so I can't speak to the particular
things he sees. I teach all over the US, write the books, and
occasionally step into companies to unscrew up whatever they have
going on. Here's what I've learned in 20 years of doing this, but, as
I said, just the highlights.

---

**It doesn't matter what universities teach** If you think a
university is a trade school and that the graduates are going to show
up ready to work, it's already game over. If someone coming out of a
university can't pick up a new language, why would you hire them? They
should already have the skills to learn new tools. Outside of Perl,
they are going to have to learn all sorts of things to be useful,
including...

**Your architecture matters more than the language** It's much
harder to figure out how all the pieces fit together than it is to use
some Perl in a method. [Ævar Arnfjörð Bjarmason said as much in the reddit
thread](http://www.reddit.com/r/perl/comments/2p6tqd/perl_recruitment_thoughts/cmu68op). But, you didn't design what you have and the documentation
is a mess, even though you provide a wiki that no one updates.
Everything accreted over years from a succession of programmers who
quit when they got tired of the mess. You don't have anyone in charge
of the idea, so you let anyone with a keyboard do it based on whatever
fire you want to put out that week. And you have no tests, so everyone
is afraid to change things. Because...

**You offer no professional development** I have more than a couple
of very successful customers who make their own Perl programmers. They
have a career ladder that takes people from almost no tech skills and
turns them into programmers in a couple of years. Yeah, years. They
are pro-active in professional development and there's something for
new hires in the trenches to aspire to. Are you fully mining the job
market or merely filling a position for several months until you wear
out someone? Which leads too..

**Your company has a bad reputation** I've tried to help at more
than a few places where the word about town is to avoid your company.
Part of my work is always to track down people who *used* to work
on the code to find out what advice they have. Most of the time I get
warnings that aren't technical and the people who might fill the job
know the same gossip. But, that doesn't matter if...

**You aren't doing something interesting** The really good
Programmers I know don't care that much about the tools as long as
they are decent tools. They want to work on interesting problems. Of
all the problems out there, most aren't interesting. Of the ones that
can be, bad management can make them intolerable. Some companies think
they can make up for that with money. Some think they can offer equity
because they have a three year exit plan that involves a buy out,
so...

**You don't pay enough** Well, you don't for the level of
prepackaged skills you want to parachute into your mess. Even then,
you kill them with the death of a thousand cuts. You start by saying
you want them to work on a test suite and within a month they are
fighting fires like the rest of the burnt out crew. Your daily agile
standup takes 45 minutes and people sit down. You never get out of the
mess that's causing the problem. But...

**Pay doesn't matter if you suck** I know plenty of really good
Programmers who'd rather be poor than work in most environments
managers let them have. I know of very few places where the
programmers don't gripe about the obstacles to getting things done,
and many of those gripes are social obstacles. Sometimes that means
you need to fire particular people that bring down the entire team. I
know many companies that bleed talent because they don't get rid of
the non-performing black holes of negativity who don't document the
institutional knowledge that has become their job security.

**The people you want to hire don't know about your job** If you're
merely posting job adverts, you're only getting the people who don't
have jobs. I've never hired a Perl programmer that way. I hire them
away from jobs they already have when they aren't looking. This is why
I (and others) invented Perl mongers. We designed Perl mongers as a
business networking medium. Presentations were rare in the beginning.
Drinking and socializing were the intent. Personal relationships lead
to opportunities. That's not what happens now in many places. You
don't know the rock stars who might turn around your company because
you don't even know who they are, much less what they're interested
in.

**You aren't where anyone is** You might be aces in everything, but
if you've set up shop where nobody is and where nobody wants to go to,
don't expect the same response to a job opening that you'd get in San
Francisco, New York, or London.

---

In short, the language doesn't matter. There's much more going on in
the job market and the employment opportunities that people like to
blame on the language. As programmers, however, we know the ultimate
excuse of the poor worker is the tools.

We don't need everyone using Perl to make it smart for businesses; we
need just enough to make it easy to get things done. We have enough.
Anyone wanting to use the language is going to find an engaged,
interested, enthusiastic, and motivated community. They are going to
find fresh releases. They will find libraries, modules, and frameworks
to handle what they need. They will get their questions answered by
top-shelf people. They will find answers in StackOverflow. The
employers have all the tools they need to create Perl programmers if
that's the language they want to use. There's not anything we can do
to make it an order of magnitude easier for them.

But then, my other rant is that we've run out of Programmers. We have
people who program for money, but that's not the same thing. Out of
all the people in the world, only so many have the talent, skill, and
motivation to design (not just type) computer programs. I think that
number is very small. That you like and enjoy futzing with computers
doesn't make you a Programmer any more than me reading gun magazines
or firing a pistol at the range makes me a Navy SEAL.

Your real trick is to hire one real Programmer and let him handle a
crew of people with moderate skills (perhaps no talent, though). But
then, you'd have to actually think about organizational dynamics and
how to train a tech person to be a manager then not piss them off so
they leaves.


